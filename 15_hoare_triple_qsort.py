from typing import TypeVar, List

T = TypeVar('T')


# Предусловие: {
#    arr - массив элементов типа T,
#    для двух T иммется операция сравнения
# }
def qsort(arr: List[T]) -> List[T]:
    if not arr:
        return []
    pivot = arr[0]
    left = [x for x in arr[1:] if x < pivot]
    right = [x for x in arr[1:] if x > pivot]
    return qsort(left) + [pivot] + qsort(right)
# Постусловие: {
#    Возвращается: список элементов типа T, сортированный в порядке возрастания
# }
# Доказательство: {
#     P(n) = qsort корректно сортирует массив длиной n
#     P(0) всегда верно, массив из 0 элемента всегда отсортирован
#     P(1) всегда верно, массив из 1 элемента всегда отсортирован
#     Гипотеза: если P(k) верно для всех k < n, то P(n) тоже верно
#     Для n > 1 будет выполняться код
#     left  - список элементов arr меньше pivot (по свойству кода)
#     right - список элементов arr больше pivot (по свойству кода)
#     => Для реукрсивного вызова qsort(left) + [pivot] + qsort(right)
#     свойство будет верно при условии, что left и right отсортированы корректно
#     Размер k_left и k_right всегда меньше, чем длина массива n и перечисленные
#     свойства выполняются при каждом рекурсивном вызове, следовательно,
#     гипотеза подтверждается.
# }
# 
